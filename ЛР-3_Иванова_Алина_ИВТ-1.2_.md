**Дисциплина:** _Программирование. Язык СИ_

 **Преподаватели:** _Власов Дмитрий Викторович, Мельников Федор Владиславович_
 
 **Учебное заведение:** _РГПУ им. А. И. Герцена_
 
# Лабораторная работа №3
## Тема:  Программирование. Язык СИ. Структуры. Объединения. Перечисления. Задачи.
 

**Автор:** Иванова А.Д., группа ИВТ-1.2  

---
## Комплект 1: Структуры

## Задание 1.1
Создать некоторую структуру с указателем на некоторую функцию в качестве поля. 
Вызвать эту функцию через имя переменной этой структуры и поле указателя на функцию.

### Список идентификаторов:

| Имя         | Тип                   | Смысл                                  |
|-------------|------------------------|----------------------------------------|
| `add`       | `int (int, int)`       | Функция сложения двух чисел             |
| `FuncStruct`| `struct`               | Структура, содержащая указатель на функцию |
| `func`      | `int (*)(int, int)`    | Указатель на функцию                    |
| `s`         | `struct FuncStruct`    | Экземпляр структуры                    |
| `result`    | `int`                 | Результат вызова функции               |

### Код программы:

```c
#include <stdio.h>

int add(int a, int b) {
    return a + b;
}

// Структура с указателем на функцию
struct FuncStruct {
    int (*func)(int, int);
};

int main() {
    struct FuncStruct s;
    s.func = &add;

    int result = s.func(5, 7); 
    printf("Результат: %d\n", result);

    return 0;
}
```
### Результаты выполненной работы:

![](3.1.png)

---

## Задание 1.2
Создать структуру для вектора в 3-х мерном пространстве. 
Реализовать и использховать в своей программе следующие операции над векторами:

 • скалярное умножение векторов;
 
 • векторное произведение;
 
 • модуль вектора;
 
 • распечатка вектора в консоли.
 
 В структуре вектора указать имя вектора в качестве отдельного поля
 этой структуры.
 
### Математическая модель:

$$
|\vec{a}| = \sqrt{a_x^2 + a_y^2 + a_z^2}
$$

### Список идентификаторов:

| Имя              | Тип                     | Смысл                                             |
|------------------|--------------------------|--------------------------------------------------|
| `Vector3D`       | `struct`                 | Структура трёхмерного вектора                   |
| `name`           | `char[20]`               | Имя вектора                                     |
| `x`, `y`, `z`    | `double`                 | Координаты вектора                               |
| `dot_product`    | `double (Vector3D*, Vector3D*)` | Функция скалярного произведения                   |
| `cross_product`  | `Vector3D (Vector3D*, Vector3D*)` | Функция векторного произведения                  |
| `vector_magnitude` | `double (Vector3D*)`   | Функция вычисления модуля                       |
| `print_vector`   | `void (Vector3D*)`      | Печать вектора                                  |
| `v1`, `v2`      | `Vector3D`              | Примеры векторов                                |
| `cp`            | `Vector3D`              | Результат векторного произведения                |
| `res`           | `Vector3D`              | Временная переменная для результата              |

### Код программы:

```c
#include <stdio.h>
#include <math.h>

typedef struct {
    char name[20];
    double x, y, z;
} Vector3D;

double dot_product(Vector3D *v1, Vector3D *v2) {
    return v1->x * v2->x + v1->y * v2->y + v1->z * v2->z;
}

Vector3D cross_product(Vector3D *v1, Vector3D *v2) {
    Vector3D res;
    res.x = v1->y * v2->z - v1->z * v2->y;
    res.y = v1->z * v2->x - v1->x * v2->z;
    res.z = v1->x * v2->y - v1->y * v2->x;
    return res;
}

double vector_magnitude(Vector3D *v) {
    return sqrt(v->x * v->x + v->y * v->y + v->z * v->z);
}

void print_vector(Vector3D *v) {
    printf("%s: (%.2f, %.2f, %.2f)\n", v->name, v->x, v->y, v->z);
}

int main() {
    Vector3D v1 = {"v1", 1, 2, 3};
    Vector3D v2 = {"v2", 4, 5, 6};

    printf("скалярное произведение: %.2f\n", dot_product(&v1, &v2));

    Vector3D cp = cross_product(&v1, &v2);
    printf("векторное произведение: ");
    print_vector(&cp);

    printf("модуль вектора v1: %.2f\n", vector_magnitude(&v1));
    printf("модуль вектора v2: %.2f\n", vector_magnitude(&v2));

    return 0;
}
```
### Результаты выполненной работы:

![](3.2.png)

---

## Задание 1.3
 Вычислить, используя структуру комплексного числа, комплексную экспоненту `exp(z)` некоторого z принадлежит C

### Математическая модель:

$$
\exp(z) = 1 + z + \frac{1}{2!}z^2 + \frac{1}{3!}z^3 + \dots + \frac{1}{n!}z^n.
$$

### Список идентификаторов:

| Имя             | Тип                      | Смысл                                              |
|-----------------|---------------------------|----------------------------------------------------|
| `Complex`       | `struct`                  | Представление комплексного числа                    |
| `real`, `imag`  | `double`                  | Действительная и мнимая части                      |
| `complex_add`   | `Complex (Complex, Complex)`| Сложение комплексных чисел                          |
| `complex_mult`  | `Complex (Complex, Complex)`| Умножение комплексных чисел                        |
| `complex_divide`| `Complex (Complex, double)`| Деление комплексного числа на вещественное          |
| `exp_z`         | `Complex (Complex, int)`   | Вычисление экспоненты комплексного числа            |
| `term`          | `Complex`                | Текущий член разложения                           |
| `factorial`     | `double`                 | Накопление факториала                             |
| `result`        | `Complex`                | Результирующий ряд                                |
| `z`            | `Complex`                | Входной аргумент для exp                            |

### Код программы:

```c
#include <stdio.h>
#include <math.h>

typedef struct {
    double real;
    double imag;
} Complex;

Complex complex_add(Complex a, Complex b) {
    return (Complex){a.real + b.real, a.imag + b.imag};
}

Complex complex_mult(Complex a, Complex b) {
    return (Complex){
        a.real * b.real - a.imag * b.imag,
        a.real * b.imag + a.imag * b.real
    };
}

Complex complex_divide(Complex c, double n) {
    return (Complex){c.real / n, c.imag / n};
}

Complex exp_z(Complex z, int n_terms) {
    Complex result = {0.0, 0.0}; // e^z = сумма
    Complex term = {1.0, 0.0};   // начальный член — 1
    double factorial = 1.0;

    for (int i = 0; i < n_terms; ++i) {
        result = complex_add(result, term);
        factorial *= (i + 1);
        term = complex_divide(complex_mult(term, z), factorial);
    }

    return result;
}

int main() {
    Complex z = {1.0, 1.0};
    Complex result = exp_z(z, 10);

    printf("exp(%.1f + %.1fi) ≈ %.4f + %.4fi\n",
           z.real, z.imag, result.real, result.imag);

    return 0;
}
```
### Результаты выполненной работы:

![](3.3.png)

---

## Задание 4
Напишите функцию `find_unique_elements`, которая принимает вектор элементов типа `T` и возвращает вектор уникальных элементов. Определите трейт `Unique` с методом `is_unique`.

### Список идентификаторов:

| Имя     | Тип       | Смысл                         |
|---------|------------|-------------------------------|
| `Date` | `struct`   | Структура даты                |
| `day`  | `unsigned : 5` | День месяца (1–31)         |
| `month`| `unsigned : 4` | Месяц (1–12)               |
| `year` | `unsigned : 11` | Год (0–2047)              |
| `birth`| `Date`     | Экземпляр структуры даты     |

### Код программы:

```c
#include <stdio.h>

typedef struct {
    unsigned day : 5;   // от 1 до 31
    unsigned month : 4;  // от 1 до 12
    unsigned year : 11; // от 0 до 2047 (год)
} Date;

int main() {
    Date birth = {10, 11, 2006};

    printf("Дата рождения: %u.%u.%u\n", birth.day, birth.month, birth.year);

    return 0;
}

```
### Результаты выполненной работы:

![](3.4.png)

---

## Задание 5
Напишите функцию `sum_collection`, которая принимает коллекцию элементов типа `T` и возвращает их сумму. Ограничьте тип `T` требованием наличия метода `addition()` в трейте `Addable`.

### Список идентификаторов:

| Имя          | Тип            | Смысл                                      |
|---------------|------------------|--------------------------------------------|
| `Node`       | `struct`        | Узел двусвязного списка                   |
| `data`       | `int`           | Хранимое значение                         |
| `prev`       | `Node*`         | Указатель на предыдущий узел             |
| `next`       | `Node*`         | Указатель на следующий узел               |
| `create_node`| `Node*()`       | Создание нового узла                      |
| `insert_end` | `void (Node**, int)` | Добавление узла в конец               |
| `print_forward` | `void (Node*)` | Обход списка вперёд                      |
| `print_backward`| `void (Node*)` | Обход списка назад                        |
| `head`       | `Node*`         | Указатель на первый узел                  |
| `tail`       | `Node*`         | Указатель на последний узел               |

### Код программы:

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int data;
    struct Node *prev;
    struct Node *next;
} Node;

Node* create_node(int value) {
    Node *new_node = malloc(sizeof(Node));
    new_node->data = value;
    new_node->prev = NULL;
    new_node->next = NULL;
    return new_node;
}

void insert_end(Node **head, int value) {
    Node *new_node = create_node(value);
    if (!*head) {
        *head = new_node;
        return;
    }
    Node *current = *head;
    while (current->next) {
        current = current->next;
    }
    current->next = new_node;
    new_node->prev = current;
}

void print_forward(Node *head) {
    Node *current = head;
    while (current) {
        printf("%d -> ", current->data);
        current = current->next;
    }
    printf("NULL\n");
}

void print_backward(Node *tail) {
    Node *current = tail;
    while (current) {
        printf("%d -> ", current->data);
        current = current->prev;
    }
    printf("NULL\n");
}

int main() {
    Node *head = NULL;

    insert_end(&head, 10);
    insert_end(&head, 20);
    insert_end(&head, 30);

    printf("прямой обход:\n");
    print_forward(head);

    // Получаем последний элемент для обратного обхода
    Node *tail = head;
    while (tail && tail->next) {
        tail = tail->next;
    }

    printf("обратный обход:\n");
    print_backward(tail);

    return 0;
}
```

### Результаты выполненной работы:

![](1.5.png)

---
## Комплект 2: Объединения и перечисления
## Задание 2.1
Напишите программу, которая использует указатель на некоторое объединение union.

### Список идентификаторов:

| Имя               | Тип             | Смысл                                |
|-------------------|------------------|-------------------------------------|
| `Collection<T>`   | `struct`         | Обобщенная структура коллекции      |
| `items`           | `Vec<T>`         | Вектор элементов                    |
| `add_element`     | `fn(T)`          | Добавляет элемент в коллекцию       |
| `get_element`     | `Option<&T>`     | Получает элемент по индексу         |
| `remove_element`  | `Option<T>`      | Удаляет элемент по индексу          |

### Код программы:

```rust
#[derive(Debug)]
struct Collection<T: Clone> {
    items: Vec<T>,
}

impl<T: Clone> Collection<T> {
    fn new() -> Self {
        Collection { items: Vec::new() }
    }

    fn add_element(&mut self, item: T) {
        self.items.push(item);
    }

    fn get_element(&self, index: usize) -> Option<&T> {
        self.items.get(index)
    }

    fn remove_element(&mut self, index: usize) -> Option<T> {
        if index < self.items.len() {
            Some(self.items.remove(index))
        } else {
            None
        }
    }
}

fn main() {
    let mut collection = Collection::new();
    collection.add_element(String::from("rust"));
    collection.add_element(String::from("программирование"));

    if let Some(item) = collection.get_element(0) {
        println!("элемент в индексе 0: {}", item);
    }

    if let Some(removed) = collection.remove_element(1) {
        println!("удаленный элемент: {}", removed);
    }
}
```
### Результаты выполненной работы:

![](7.6.png)

---

## Задание 7
Создайте трейт `Summable`, который требует реализации метода `sum(&self) -> u32` для типов, поддерживающих сложение. Реализуйте этот трейт для структуры `Pair<T>`, которая содержит два поля типа `T`. Добавьте ограничение на тип `T` для поддержки сложения.

### Список идентификаторов:

| Имя        | Тип             | Смысл                                  |
|------------|------------------|---------------------------------------|
| `Summable` | `trait`          | Трейт для объектов, поддерживающих сложение |
| `sum`      | `fn() -> u32`    | Возвращает сумму элементов            |
| `Pair<T>`  | `struct`         | Структура, содержащая два элемента    |
| `first`    | `T`              | Первый элемент                         |
| `second`   | `T`              | Второй элемент                         |
| `Add`      | `trait`          | Трейт сложения                         |

### Код программы:

```rust
use std::ops::Add;

// Определяем трейт Summable
trait Summable {
    fn sum(&self) -> u32;
}

// Структура Pair<T>, которая содержит два поля типа T
#[derive(Debug)]
struct Pair<T>
where
    T: Add<Output = T> + Copy + Into<u32>,
{
    first: T,
    second: T,
}

// Реализуем трейт Summable для Pair<T>
impl<T> Summable for Pair<T>
where
    T: Add<Output = T> + Copy + Into<u32>,
{
    fn sum(&self) -> u32 {
        (self.first + self.second).into()
    }
}

fn main() {
    let pair = Pair {
        first: 10_u32,
        second: 20_u32,
    };
    println!("сумма пары: {}", pair.sum()); 
}
```
### Результаты выполненной работы:

![](7.7.png)

--- 

